<!-- noctura-vision/backend/wstest.html (v2 with fixes) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NocturaVision WebSocket Test</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        .container { display: flex; gap: 20px; margin-top: 20px; }
        video, img { border: 2px solid #ccc; max-width: 480px; }
        /* --- FIX 1: Flip the local webcam preview to match the un-mirrored output --- */
        #webcam { transform: scaleX(-1); }
        .controls { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
        #status { font-weight: bold; }
    </style>
</head>
<body>
    <h1>NocturaVision WebSocket Test (v2)</h1>
    <div class="controls">
        <button id="startButton">Start Webcam</button>
        <button id="stopButton" disabled>Stop Webcam</button>
        <div>
            <label for="modelSelect">Model:</label>
            <select id="modelSelect">
                <option value="mask2former">Mask2Former</option>
                <option value="maskrcnn">Mask R-CNN</option>
            </select>
        </div>
        <div>
            <label><input type="checkbox" id="enhanceCheckbox" checked> Apply Low-Light Enhancement</label>
        </div>
        <div>
            <label><input type="checkbox" id="fpsCheckbox" checked> Show FPS</label>
        </div>
        <p>Status: <span id="status">Idle</span></p>
    </div>
    <div class="container">
        <div>
            <h2>Original Webcam (Un-mirrored)</h2>
            <video id="webcam" autoplay playsinline></video>
        </div>
        <div>
            <h2>Processed Output</h2>
            <img id="processedImage" />
        </div>
    </div>

    <script>
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const webcamVideo = document.getElementById('webcam');
        const processedImage = document.getElementById('processedImage');
        const statusSpan = document.getElementById('status');
        const modelSelect = document.getElementById('modelSelect');
        const enhanceCheckbox = document.getElementById('enhanceCheckbox');
        const fpsCheckbox = document.getElementById('fpsCheckbox');

        let websocket;
        let stream;
        // --- FIX 2: We will use a flag and requestAnimationFrame instead of setInterval ---
        let isStreaming = false;

        const WS_URL = "ws://127.0.0.1:8000/ws/process_video";

        startButton.onclick = async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
                webcamVideo.srcObject = stream;
                statusSpan.textContent = 'Webcam started.';
                
                websocket = new WebSocket(WS_URL);

                websocket.onopen = () => {
                    statusSpan.textContent = 'WebSocket Connected. Processing...';
                    startButton.disabled = true;
                    stopButton.disabled = false;
                    isStreaming = true;
                    // --- FIX 2: Kick off the first frame processing ---
                    requestAnimationFrame(processAndSendFrame); 
                };

                websocket.onmessage = (event) => {
                    processedImage.src = event.data;
                    // --- FIX 2: Request the NEXT frame only after the PREVIOUS one is received ---
                    if (isStreaming) {
                        requestAnimationFrame(processAndSendFrame);
                    }
                };

                websocket.onclose = () => {
                    statusSpan.textContent = 'WebSocket Disconnected.';
                    stopStreaming();
                };

                websocket.onerror = (error) => {
                    statusSpan.textContent = 'WebSocket Error!';
                    console.error("WebSocket Error:", error);
                    stopStreaming();
                };

            } catch (err) {
                console.error("Error starting webcam:", err);
                statusSpan.textContent = 'Error starting webcam!';
            }
        };

        stopButton.onclick = () => {
            stopStreaming();
        };

        // --- FIX 2: This function now replaces the old setInterval loop ---
        function processAndSendFrame() {
            if (!isStreaming || !websocket || websocket.readyState !== WebSocket.OPEN) {
                return;
            }
            if (!webcamVideo.videoWidth || !webcamVideo.videoHeight) {
                // If video isn't ready, try again on the next animation frame
                requestAnimationFrame(processAndSendFrame);
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = webcamVideo.videoWidth;
            canvas.height = webcamVideo.videoHeight;
            const context = canvas.getContext('2d');
            
            // Un-mirror the image data before sending
            context.translate(canvas.width, 0);
            context.scale(-1, 1);
            context.drawImage(webcamVideo, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/jpeg');

            const payload = {
                image_b64: dataUrl,
                model_type: modelSelect.value,
                apply_enhancement: enhanceCheckbox.checked,
                show_fps: fpsCheckbox.checked,
                score_threshold: 0.5,
                input_max_dim: 720
            };
            websocket.send(JSON.stringify(payload));
        }

        function stopStreaming() {
            isStreaming = false;
            if (websocket) websocket.close();
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                webcamVideo.srcObject = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            statusSpan.textContent = 'Idle';
            processedImage.src = "";
        }
    </script>
</body>
</html>
